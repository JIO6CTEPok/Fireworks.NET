using System;

namespace FireworksNet
{
    /// <summary>
    /// Stores user-defined constants that control algorithm run
    /// </summary>
    /// <remarks>Uses notation described in 2010 paper</remarks>
    public class AlgorithmSetup
    {
        private Object fieldInitLock = new Object();

        // TODO: I don't like Double.NaN and -1 here. Maybe nullable type?..
        protected Double minAllowedExplosionSparksNumberExact = Double.NaN;
        protected Double maxAllowedExplosionSparksNumberExact = Double.NaN;
        protected Int32 minAllowedExplosionSparksNumber = -1;
        protected Int32 maxAllowedExplosionSparksNumber = -1;

        /// <summary>
        /// n - Number of fireworks (initial or selected on each step)
        /// </summary>
        public Int32 LocationsNumber { get; set; }

        /// <summary>
        /// m - Parameter controlling the total number of sparks generated
        /// by <see cref="LocationsNumber"/> fireworks
        /// </summary>
        public Double ExplosionSparksNumberModifier { get; set; }

        /// <summary>
        /// a - Constant,
        /// has to be 0 &lt; a &lt; <paramref name="ExplosionSparksNumberUpperBound"/>
        /// </summary>
        public Double ExplosionSparksNumberLowerBound { get; set; }

        /// <summary>
        /// b - Constant,
        /// has to be <paramref name="ExplosionSparksNumberLowerBound"/> &lt; b &lt; 1
        /// </summary>
        public Double ExplosionSparksNumberUpperBound { get; set; }

        /// <summary>
        /// Â - Maximum explosion amplitude
        /// </summary>
        public Double ExplosionSparksMaximumAmplitude { get; set; }

        /// <summary>
        /// m̂ - Number of specific sparks generated by an explosion
        /// </summary>
        public Int32 SpecificSparksNumber { get; set; }

        /// <summary>
        /// Maximum allowed error (difference between real optimum and best
        /// existing firework or spark)
        /// </summary>
        public Double TerminationDesiredAccuracy { get; set; }

        /// <summary>
        /// Minimum allowed explosion sparks number (not rounded)
        /// </summary>
        /// <remarks>Pre-calculated for this run</remarks>
        public Double MinAllowedExplosionSparksNumberExact
        {
            get
            {
                if (Double.IsNaN(minAllowedExplosionSparksNumberExact))
                {
                    lock (fieldInitLock)
                    {
                        if (Double.IsNaN(minAllowedExplosionSparksNumberExact))
                        {
                            minAllowedExplosionSparksNumberExact = ExplosionSparksNumberLowerBound * ExplosionSparksNumberModifier;
                        }
                    }
                }

                return minAllowedExplosionSparksNumberExact;
            }
        }

        /// <summary>
        /// Maximum allowed explosion sparks number (not rounded)
        /// </summary>
        /// <remarks>Pre-calculated for this run</remarks>
        public Double MaxAllowedExplosionSparksNumberExact
        {
            get
            {
                if (Double.IsNaN(maxAllowedExplosionSparksNumberExact))
                {
                    lock (fieldInitLock)
                    {
                        if (Double.IsNaN(maxAllowedExplosionSparksNumberExact))
                        {
                            maxAllowedExplosionSparksNumberExact = ExplosionSparksNumberUpperBound * ExplosionSparksNumberModifier;
                        }
                    }
                }

                return maxAllowedExplosionSparksNumberExact;
            }
        }

        /// <summary>
        /// Minimum allowed explosion sparks number (rounded)
        /// </summary>
        /// <remarks>Pre-calculated for this run</remarks>
        public Int32 MinAllowedExplosionSparksNumber
        {
            get
            {
                if (minAllowedExplosionSparksNumber < 0)
                {
                    lock (fieldInitLock)
                    {
                        if (minAllowedExplosionSparksNumber < 0)
                        {
                            minAllowedExplosionSparksNumber = (int)Math.Round(MinAllowedExplosionSparksNumberExact, MidpointRounding.AwayFromZero);
                        }
                    }
                }

                return minAllowedExplosionSparksNumber;
            }
        }

        /// <summary>
        /// Maximum allowed explosion sparks number (rounded)
        /// </summary>
        /// <remarks>Pre-calculated for this run</remarks>
        public Int32 MaxAllowedExplosionSparksNumber
        {
            get
            {
                if (maxAllowedExplosionSparksNumber < 0)
                {
                    lock (fieldInitLock)
                    {
                        if (maxAllowedExplosionSparksNumber < 0)
                        {
                            maxAllowedExplosionSparksNumber = (int)Math.Round(MaxAllowedExplosionSparksNumberExact, MidpointRounding.AwayFromZero);
                        }
                    }
                }

                return maxAllowedExplosionSparksNumber;
            }
        }
    }
}